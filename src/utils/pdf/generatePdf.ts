import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

/**
 * Generate a PDF report of selected benefits
 * @param {Array} benefits - Benefits to include in the report
 * @param {Object} userData - User information for personalization
 * @returns {Promise<Uint8Array>} PDF document as binary data
 */
export const generateBenefitsReport = async (
  benefits: any[] = [], 
  userData: Record<string, any> = {}
): Promise<Uint8Array> => {
  // Create a new PDF document
  const pdfDoc = await PDFDocument.create();
  
  // Embed standard fonts
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const timesRoman = await pdfDoc.embedFont(StandardFonts.TimesRoman);
  
  // Set font size defaults
  const titleFontSize = 16;
  const headerFontSize = 12;
  const normalFontSize = 10;
  const smallFontSize = 8;
  
  // Add a page
  let page = pdfDoc.addPage([600, 800]);
  
  // Page margins
  const margin = 50;
  let currentY = page.getHeight() - margin;
  
  // Set the font and size for the title
  page.setFont(helveticaBold);
  page.setFontSize(titleFontSize);
  
  // Add title
  const title = "Veterans Benefits Summary – Generated by VetNav";
  const titleWidth = helveticaBold.widthOfTextAtSize(title, titleFontSize);
  page.drawText(title, {
    x: (page.getWidth() - titleWidth) / 2, // Center the title
    y: currentY,
    color: rgb(0.1, 0.1, 0.5), // Dark blue
  });
  
  // Move down after the title
  currentY -= 30;
  
  // Add timestamp
  page.setFont(helveticaFont);
  page.setFontSize(smallFontSize);
  const date = new Date().toLocaleDateString();
  const time = new Date().toLocaleTimeString();
  const timestamp = `Generated on ${date} at ${time}`;
  page.drawText(timestamp, {
    x: margin,
    y: currentY,
    color: rgb(0.4, 0.4, 0.4),
  });
  
  // Add user selections if available
  if (userData.selections) {
    currentY -= 20;
    page.setFontSize(smallFontSize);
    let selectionText = "Filtered by: ";
    
    if (userData.selections.benefitType) {
      selectionText += `Type: ${userData.selections.benefitType}, `;
    }
    if (userData.selections.userType) {
      selectionText += `For: ${userData.selections.userType}, `;
    }
    if (userData.selections.filters && userData.selections.filters.length > 0) {
      selectionText += `Filters: ${userData.selections.filters.join(', ')}`;
    }
    
    page.drawText(selectionText, {
      x: margin,
      y: currentY,
      color: rgb(0.4, 0.4, 0.4),
    });
  }
  
  // Add a separator line
  currentY -= 15;
  page.drawLine({
    start: { x: margin, y: currentY },
    end: { x: page.getWidth() - margin, y: currentY },
    thickness: 1,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  // Move down after the separator
  currentY -= 20;
  
  // Group benefits by priority
  const priorityGroups = {
    'critical': [],
    'financial': [],
    'life-improving': [],
    'optional': []
  };
  
  benefits.forEach(benefit => {
    if (priorityGroups[benefit.priority]) {
      priorityGroups[benefit.priority].push(benefit);
    }
  });
  
  // Priority labels
  const priorityLabels = {
    'critical': 'Critical Benefits',
    'financial': 'Financial Benefits',
    'life-improving': 'Life-Improving Benefits',
    'optional': 'Additional Benefits'
  };
  
  // Iterate through priority groups
  for (const [priority, priorityBenefits] of Object.entries(priorityGroups)) {
    if (priorityBenefits.length === 0) continue;
    
    // Check if we need a new page
    if (currentY < 100) {
      // Add a new page
      page = pdfDoc.addPage([600, 800]);
      currentY = page.getHeight() - margin;
    }
    
    // Add priority section header
    page.setFont(helveticaBold);
    page.setFontSize(headerFontSize);
    page.drawText(priorityLabels[priority], {
      x: margin,
      y: currentY,
      color: rgb(0.2, 0.2, 0.2),
    });
    
    // Move down after the priority header
    currentY -= 20;
    
    // Add benefits in this priority group
    for (const benefit of priorityBenefits) {
      // Check if we need a new page
      if (currentY < 180) {
        // Add a new page
        page = pdfDoc.addPage([600, 800]);
        currentY = page.getHeight() - margin;
      }
      
      // Benefit title
      page.setFont(helveticaBold);
      page.setFontSize(normalFontSize);
      page.drawText(benefit.title, {
        x: margin,
        y: currentY,
        color: rgb(0.1, 0.1, 0.5), // Dark blue
      });
      
      // Move down after title
      currentY -= 15;
      
      // Category
      page.setFont(helveticaFont);
      page.setFontSize(smallFontSize);
      page.drawText(`Category: ${benefit.category.charAt(0).toUpperCase() + benefit.category.slice(1)}`, {
        x: margin,
        y: currentY,
        color: rgb(0.4, 0.4, 0.4),
      });
      
      // Move down after category
      currentY -= 15;
      
      // Description
      page.setFont(timesRoman);
      page.setFontSize(normalFontSize);
      
      // Handle description wrapping
      const maxWidth = page.getWidth() - (margin * 2);
      const words = benefit.description.split(' ');
      let line = '';
      
      for (const word of words) {
        const testLine = line + word + ' ';
        const testWidth = timesRoman.widthOfTextAtSize(testLine, normalFontSize);
        
        if (testWidth > maxWidth) {
          page.drawText(line, {
            x: margin,
            y: currentY,
            color: rgb(0, 0, 0),
          });
          line = word + ' ';
          currentY -= 15;
        } else {
          line = testLine;
        }
      }
      
      // Draw the last line of description
      if (line) {
        page.drawText(line, {
          x: margin,
          y: currentY,
          color: rgb(0, 0, 0),
        });
        currentY -= 15;
      }
      
      // Add underused warning if applicable
      if (benefit.underused) {
        currentY -= 5;
        page.setFont(helveticaBold);
        page.setFontSize(normalFontSize);
        page.drawText('⭐ Underused Benefit', {
          x: margin,
          y: currentY,
          color: rgb(0.8, 0.6, 0.1), // Amber color
        });
        currentY -= 15;
      }
      
      // Source URL
      page.setFont(helveticaFont);
      page.setFontSize(smallFontSize);
      page.drawText(`Source: ${benefit.source}`, {
        x: margin,
        y: currentY,
        color: rgb(0.2, 0.4, 0.8), // Blue for URL
      });
      
      // Add some space between benefits
      currentY -= 30;
    }
    
    // Add space between priority sections
    currentY -= 10;
  }
  
  // Add footer with page numbers
  const totalPages = pdfDoc.getPageCount();
  for (let i = 0; i < totalPages; i++) {
    const currentPage = pdfDoc.getPage(i);
    currentPage.setFont(helveticaFont);
    currentPage.setFontSize(smallFontSize);
    currentPage.drawText(`Page ${i + 1} of ${totalPages}`, {
      x: currentPage.getWidth() - margin - 60,
      y: margin / 2,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  // Serialize the PDF to bytes
  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
};

/**
 * Download the generated PDF
 * @param {Uint8Array} pdfBytes - PDF document as binary data
 * @param {string} fileName - Name of the file to download
 */
export const downloadPdf = (pdfBytes: Uint8Array, fileName: string = 'vetnav_summary.pdf'): void => {
  // Create a blob from the PDF bytes
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  
  // Create a URL for the blob
  const url = URL.createObjectURL(blob);
  
  // Create a temporary link element
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName;
  
  // Add the link to the document
  document.body.appendChild(link);
  
  // Click the link to trigger the download
  link.click();
  
  // Clean up
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};
